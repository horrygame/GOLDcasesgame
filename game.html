<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Свободная игра - Битва Крепостей</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Times New Roman', serif;
        }
        
        body {
            background: linear-gradient(135deg, #3e2723, #5d4037);
            color: #f5e8c8;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #game-container {
            position: relative;
            width: 1200px;
            height: 800px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
            border: 8px solid #5d4037;
        }
        
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 5;
        }
        
        .ui-panel {
            background: rgba(93, 64, 55, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            border: 2px solid #8d6e63;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: #f5e8c8;
        }
        
        .button {
            background: linear-gradient(to bottom, #8d6e63, #6d4c41);
            color: #fff;
            border: none;
            padding: 15px 30px;
            font-size: 22px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            text-align: center;
            border: 2px solid #5d4037;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .button:hover {
            background: linear-gradient(to bottom, #a1887f, #8d6e63);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.6);
        }
        
        .character-buttons {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 10px;
            background: rgba(93, 64, 55, 0.8);
            border-top: 2px solid #8d6e63;
            z-index: 5;
        }
        
        .character-button {
            width: 80px;
            height: 80px;
            background: linear-gradient(to bottom, #8d6e63, #6d4c41);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid #5d4037;
            transition: all 0.3s;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .character-button:hover {
            transform: scale(1.05);
            background: linear-gradient(to bottom, #a1887f, #8d6e63);
        }
        
        .character-button.disabled {
            background: linear-gradient(to bottom, #795548, #5d4037);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .character-button-icon {
            width: 40px;
            height: 40px;
            margin-bottom: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #5d4037;
            border-radius: 3px;
        }
        
        .character-button-name {
            font-size: 10px;
            text-align: center;
            color: #fff;
            font-weight: bold;
        }
        
        .character-button-cost {
            font-size: 10px;
            color: #ffd54f;
            font-weight: bold;
        }
        
        .programming-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 350px;
            height: 760px;
            background: rgba(93, 64, 55, 0.9);
            border-radius: 5px;
            padding: 20px;
            z-index: 10;
            border: 2px solid #8d6e63;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .programming-header {
            font-size: 24px;
            color: #f5e8c8;
            text-align: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #8d6e63;
            padding-bottom: 10px;
        }
        
        .programming-textarea {
            width: 100%;
            height: 500px;
            background: #5d4037;
            color: #f5e8c8;
            border: 1px solid #8d6e63;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            resize: none;
        }
        
        .programming-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .programming-button {
            background: linear-gradient(to bottom, #8d6e63, #6d4c41);
            color: #fff;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
        }
        
        .programming-button:hover {
            background: linear-gradient(to bottom, #a1887f, #8d6e63);
        }
        
        .programming-help {
            background: rgba(121, 85, 72, 0.8);
            border-radius: 5px;
            padding: 15px;
            font-size: 12px;
            color: #f5e8c8;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .programming-help h3 {
            margin-bottom: 10px;
            color: #ffd54f;
        }
        
        .programming-help ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .programming-help li {
            margin-bottom: 5px;
            padding-left: 10px;
            border-left: 2px solid #8d6e63;
        }
        
        .hidden {
            display: none;
        }
        
        .game-result {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(61, 43, 31, 0.95);
            padding: 40px;
            border-radius: 5px;
            text-align: center;
            z-index: 20;
            border: 3px solid #8d6e63;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            width: 500px;
        }
        
        .damage-popup {
            position: absolute;
            color: #ff5252;
            font-weight: bold;
            font-size: 18px;
            pointer-events: none;
            z-index: 15;
            text-shadow: 1px 1px 2px black;
            animation: floatUp 1s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }
        
        .energy-warning {
            color: #ff5252;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .preparation-panel {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(93, 64, 55, 0.8);
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 24px;
            z-index: 5;
            border: 2px solid #8d6e63;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: #f5e8c8;
            display: flex;
            align-items: center;
            gap: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="1200" height="800"></canvas>
        
        <!-- Игровой UI -->
        <div class="game-ui">
            <button class="button" onclick="window.location.href='index.html'">← Главная</button>
            <div class="ui-panel" id="energy-panel">
                ⚡ <span id="game-energy">100</span>/<span id="game-max-energy">100</span>
            </div>
            <div class="ui-panel">
                ❤️ <span id="game-health">1000</span>
            </div>
            <div class="ui-panel">
                ⏱️ <span id="game-timer">60</span>с
            </div>
        </div>
        
        <!-- Панель подготовки -->
        <div id="preparation-panel" class="preparation-panel">
            <div>Фаза подготовки:</div>
            <div id="preparation-timer">60</div>
            <button class="button" id="start-early-btn">Начать заранее</button>
        </div>
        
        <!-- Кнопки выбора персонажей -->
        <div id="character-buttons" class="character-buttons">
            <!-- Кнопки персонажей будут добавлены через JavaScript -->
        </div>
        
        <!-- Панель программирования -->
        <div id="programming-panel" class="programming-panel hidden">
            <div class="programming-header">Программирование юнита</div>
            <textarea id="programming-textarea" class="programming-textarea" placeholder="Введите код для юнита..."></textarea>
            <div class="programming-buttons">
                <button class="programming-button" id="apply-program-btn">Применить к юниту</button>
                <button class="programming-button" id="apply-all-btn">Применить ко всем юнитам</button>
                <button class="programming-button" id="apply-type-btn">Применить ко всем этого типа</button>
                <button class="programming-button" id="close-programming-btn">Закрыть</button>
            </div>
            <div class="programming-help">
                <h3>Доступные команды:</h3>
                <ul>
                    <li>move_forward(distance) - двигаться вперед</li>
                    <li>move_backward(distance) - двигаться назад</li>
                    <li>move_left(distance) - двигаться влево</li>
                    <li>move_right(distance) - двигаться вправо</li>
                    <li>attack() - атаковать (в радиусе атаки)</li>
                    <li>move_to(x, y) - двигаться к координатам</li>
                    <li>get_enemy_coords() - получить координаты врага</li>
                </ul>
            </div>
        </div>
        
        <!-- Результат игры -->
        <div id="game-result" class="game-result hidden">
            <h2 id="result-title">ПОБЕДА!</h2>
            <p id="result-message">+1 ключ, +50 золота</p>
            <button class="button" id="continue-btn">Продолжить</button>
        </div>
    </div>

    <script>
        // Константы игры
        const SCREEN_WIDTH = 1200;
        const SCREEN_HEIGHT = 800;
        const PREPARATION_TIME = 60;
        const BATTLE_DURATION = 120;

        // Игровое состояние
        let gameState = {
            gamePhase: 'preparation',
            gold: 1000,
            energy: 100,
            maxEnergy: 100,
            playerHealth: 1000,
            maxCastleHealth: 1000,
            units: [],
            enemyUnits: [],
            enemySpawnTimer: 0,
            unitCounter: 0,
            enemyCounter: 0,
            lastGoldUpdate: 0,
            lastSecondUpdate: 0,
            preparationTimeLeft: PREPARATION_TIME,
            battleTimeLeft: BATTLE_DURATION,
            gameOver: false,
            gameResult: null,
            damagePopups: [],
            selectedCharacter: null,
            selectedUnit: null
        };

        const characters = {
            'white_guy': {
                'name': 'Белый Воин',
                'image': 'white_guy.png',
                'cost': 10,
                'health': 100,
                'damage': 20,
                'speed': 1.5,
                'attack_speed': 1.0,
                'attack_range': 80,
                'vision_range': 150,
                'description': 'Базовый боец, сбалансированные характеристики',
                'rarity': 'common',
                'ability': null,
                'owned': true
            }
        };

        const enemyTypes = [
            {health: 80, damage: 15, speed: 1.0, attack_speed: 1.0, attack_range: 70, vision_range: 120, image: 'white_guy.png'},
            {health: 50, damage: 25, speed: 1.5, attack_speed: 1.2, attack_range: 90, vision_range: 130, image: 'yellow_guy.png'},
            {health: 120, damage: 10, speed: 0.8, attack_speed: 0.8, attack_range: 60, vision_range: 110, image: 'red_guy.png'}
        ];

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Вспомогательные функции
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function loadProgress() {
            const saved = localStorage.getItem('fortressBattleProgress');
            if (saved) {
                const progress = JSON.parse(saved);
                Object.assign(gameState, progress);
                gameState.energy = gameState.maxEnergy;
                gameState.playerHealth = gameState.maxCastleHealth;
                updateStats();
            }
        }

        function updateStats() {
            document.getElementById('game-energy').textContent = gameState.energy;
            document.getElementById('game-max-energy').textContent = gameState.maxEnergy;
            document.getElementById('game-health').textContent = gameState.playerHealth;
            
            if (gameState.gamePhase === 'preparation') {
                document.getElementById('game-timer').textContent = Math.ceil(gameState.preparationTimeLeft);
                document.getElementById('preparation-timer').textContent = Math.ceil(gameState.preparationTimeLeft);
            } else if (gameState.gamePhase === 'battle') {
                document.getElementById('game-timer').textContent = Math.ceil(gameState.battleTimeLeft);
            }
        }

        function createCharacterButtons() {
            const container = document.getElementById('character-buttons');
            container.innerHTML = '';
            
            Object.keys(characters).forEach(charId => {
                const character = characters[charId];
                const button = document.createElement('div');
                button.className = 'character-button';
                button.dataset.characterId = charId;
                
                button.innerHTML = `
                    <div class="character-button-icon">
                        <div style="width:100%;height:100%;background:#5d4037;display:flex;align-items:center;justify-content:center;color:#fff;font-size:12px;">${character.name.charAt(0)}</div>
                    </div>
                    <div class="character-button-name">${character.name}</div>
                    <div class="character-button-cost">${character.cost}⚡</div>
                `;
                
                button.addEventListener('click', () => {
                    gameState.selectedCharacter = charId;
                    gameState.selectedUnit = null;
                });
                
                container.appendChild(button);
            });
        }

        function placeUnit(x, y) {
            if (gameState.selectedCharacter && gameState.energy >= characters[gameState.selectedCharacter].cost) {
                const character = characters[gameState.selectedCharacter];
                
                gameState.energy -= character.cost;
                gameState.unitCounter++;
                gameState.units.push({
                    id: `unit_${gameState.unitCounter}`,
                    characterId: gameState.selectedCharacter,
                    x: x,
                    y: y,
                    health: character.health,
                    maxHealth: character.health,
                    damage: character.damage,
                    speed: character.speed,
                    attackSpeed: character.attack_speed,
                    attackRange: character.attack_range,
                    visionRange: character.vision_range,
                    image: character.image,
                    program: [],
                    state: 'idle',
                    target: null,
                    moveTarget: null,
                    lastAttackTime: 0,
                    isExecuting: false
                });
                
                createDamagePopup(x, y, `-${character.cost}⚡`, '#4fc3f7');
                updateStats();
                return true;
            } else {
                if (gameState.energy < characters[gameState.selectedCharacter].cost) {
                    document.getElementById('energy-panel').classList.add('energy-warning');
                    setTimeout(() => {
                        document.getElementById('energy-panel').classList.remove('energy-warning');
                    }, 1000);
                    createDamagePopup(x, y, "Недостаточно энергии!", '#ef5350');
                }
                return false;
            }
        }

        function selectUnit(x, y) {
            for (let i = gameState.units.length - 1; i >= 0; i--) {
                const unit = gameState.units[i];
                if (distance(x, y, unit.x, unit.y) < 30) {
                    gameState.selectedUnit = unit;
                    gameState.selectedCharacter = null;
                    return true;
                }
            }
            return false;
        }

        function createDamagePopup(x, y, text, color) {
            gameState.damagePopups.push({
                x: x,
                y: y,
                text: text,
                color: color,
                life: 1000,
                createdAt: Date.now()
            });
        }

        function openProgrammingPanel() {
            if (gameState.selectedUnit) {
                document.getElementById('programming-textarea').value = gameState.selectedUnit.program.join('\n');
                document.getElementById('programming-panel').classList.remove('hidden');
            }
        }

        function closeProgrammingPanel() {
            document.getElementById('programming-panel').classList.add('hidden');
        }

        function applyProgram() {
            if (gameState.selectedUnit) {
                const programText = document.getElementById('programming-textarea').value;
                const programLines = programText.split('\n').filter(line => line.trim() !== '');
                gameState.selectedUnit.program = programLines;
                gameState.selectedUnit.isExecuting = true;
                closeProgrammingPanel();
            }
        }

        function applyProgramToAll() {
            const programText = document.getElementById('programming-textarea').value;
            const programLines = programText.split('\n').filter(line => line.trim() !== '');
            
            gameState.units.forEach(unit => {
                unit.program = [...programLines];
                unit.isExecuting = true;
            });
            
            closeProgrammingPanel();
        }

        function applyProgramToType() {
            if (gameState.selectedUnit) {
                const programText = document.getElementById('programming-textarea').value;
                const programLines = programText.split('\n').filter(line => line.trim() !== '');
                const characterId = gameState.selectedUnit.characterId;
                
                gameState.units.forEach(unit => {
                    if (unit.characterId === characterId) {
                        unit.program = [...programLines];
                        unit.isExecuting = true;
                    }
                });
                
                closeProgrammingPanel();
            }
        }

        function executeUnitProgram(unit) {
            if (!unit.isExecuting || unit.program.length === 0) return;
            
            for (let i = 0; i < unit.program.length; i++) {
                const command = unit.program[i].trim();
                
                if (command.startsWith('move_forward(')) {
                    const distance = parseFloat(command.match(/move_forward\((\d+)\)/)[1]);
                    unit.y = Math.max(30, unit.y - distance);
                    break;
                }
                else if (command.startsWith('move_backward(')) {
                    const distance = parseFloat(command.match(/move_backward\((\d+)\)/)[1]);
                    unit.y = Math.min(SCREEN_HEIGHT - 30, unit.y + distance);
                    break;
                }
                else if (command.startsWith('move_left(')) {
                    const distance = parseFloat(command.match(/move_left\((\d+)\)/)[1]);
                    unit.x = Math.max(30, unit.x - distance);
                    break;
                }
                else if (command.startsWith('move_right(')) {
                    const distance = parseFloat(command.match(/move_right\((\d+)\)/)[1]);
                    unit.x = Math.min(SCREEN_WIDTH - 30, unit.x + distance);
                    break;
                }
                else if (command === 'attack()') {
                    let enemyInRange = null;
                    for (const enemy of gameState.enemyUnits) {
                        if (distance(unit.x, unit.y, enemy.x, enemy.y) <= unit.attackRange) {
                            enemyInRange = enemy;
                            break;
                        }
                    }
                    
                    if (enemyInRange) {
                        enemyInRange.health -= unit.damage;
                        createDamagePopup(enemyInRange.x, enemyInRange.y, `-${unit.damage}`, '#ef5350');
                        
                        if (enemyInRange.health <= 0) {
                            gameState.enemyUnits = gameState.enemyUnits.filter(u => u !== enemyInRange);
                        }
                    }
                    break;
                }
                else if (command.startsWith('move_to(')) {
                    const match = command.match(/move_to\((\d+),\s*(\d+)\)/);
                    if (match) {
                        const x = parseInt(match[1]);
                        const y = parseInt(match[2]);
                        unit.x = Math.max(30, Math.min(SCREEN_WIDTH - 30, x));
                        unit.y = Math.max(30, Math.min(SCREEN_HEIGHT - 30, y));
                    }
                    break;
                }
            }
        }

        function spawnEnemyUnit() {
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            
            let x, y;
            const side = Math.floor(Math.random() * 4);
            
            switch (side) {
                case 0: x = Math.random() * SCREEN_WIDTH; y = -30; break;
                case 1: x = SCREEN_WIDTH + 30; y = Math.random() * SCREEN_HEIGHT; break;
                case 2: x = Math.random() * SCREEN_WIDTH; y = SCREEN_HEIGHT + 30; break;
                case 3: x = -30; y = Math.random() * SCREEN_HEIGHT; break;
            }
            
            gameState.enemyCounter++;
            
            const enemy = {
                id: `enemy_${gameState.enemyCounter}`,
                x: x,
                y: y,
                health: enemyType.health,
                maxHealth: enemyType.health,
                damage: enemyType.damage,
                speed: enemyType.speed,
                attackSpeed: enemyType.attack_speed,
                attackRange: enemyType.attack_range,
                visionRange: enemyType.vision_range,
                image: enemyType.image,
                target: {x: SCREEN_WIDTH / 2, y: SCREEN_HEIGHT / 2, isCastle: true},
                lastAttackTime: 0,
                state: 'moving'
            };
            
            gameState.enemyUnits.push(enemy);
        }

        function updateUnits() {
            const now = Date.now();
            const castleX = SCREEN_WIDTH / 2;
            const castleY = SCREEN_HEIGHT / 2;
            
            // Обновление юнитов игрока
            gameState.units.forEach(unit => {
                if (unit.isExecuting && unit.program.length > 0) {
                    executeUnitProgram(unit);
                }
            });
            
            // Обновление вражеских юнитов
            gameState.enemyUnits.forEach(enemy => {
                if (!enemy.target) {
                    let closestTarget = null;
                    let closestDistance = enemy.visionRange;
                    
                    gameState.units.forEach(unit => {
                        const dist = distance(enemy.x, enemy.y, unit.x, unit.y);
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            closestTarget = unit;
                        }
                    });
                    
                    if (!closestTarget) {
                        const distToCastle = distance(enemy.x, enemy.y, castleX, castleY);
                        if (distToCastle < enemy.visionRange) {
                            closestTarget = {x: castleX, y: castleY, isCastle: true};
                        }
                    }
                    
                    if (closestTarget) {
                        enemy.target = closestTarget;
                    }
                }
                
                if (enemy.target && enemy.state === 'moving') {
                    const dx = enemy.target.x - enemy.x;
                    const dy = enemy.target.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > enemy.attackRange) {
                        enemy.x += (dx / dist) * enemy.speed;
                        enemy.y += (dy / dist) * enemy.speed;
                    } else {
                        enemy.state = 'attacking';
                    }
                }
                
                if (enemy.target && enemy.state === 'attacking') {
                    const dist = distance(enemy.x, enemy.y, enemy.target.x, enemy.target.y);
                    
                    if (dist <= enemy.attackRange) {
                        if (!enemy.lastAttackTime || now - enemy.lastAttackTime > (1000 / enemy.attackSpeed)) {
                            if (enemy.target.isCastle) {
                                gameState.playerHealth -= enemy.damage;
                                createDamagePopup(castleX, castleY, `-${enemy.damage}`, '#ef5350');
                            } else {
                                enemy.target.health -= enemy.damage;
                                createDamagePopup(enemy.target.x, enemy.target.y, `-${enemy.damage}`, '#ef5350');
                                
                                if (enemy.target.health <= 0) {
                                    gameState.units = gameState.units.filter(u => u !== enemy.target);
                                    enemy.target = null;
                                    enemy.state = 'moving';
                                }
                            }
                            enemy.lastAttackTime = now;
                        }
                    } else {
                        enemy.state = 'moving';
                    }
                }
            });
            
            // Удаление мертвых юнитов
            gameState.units = gameState.units.filter(unit => unit.health > 0);
            gameState.enemyUnits = gameState.enemyUnits.filter(unit => unit.health > 0);
            
            // Обновление всплывающих сообщений об уроне
            const nowTime = Date.now();
            gameState.damagePopups = gameState.damagePopups.filter(popup => {
                return nowTime - popup.createdAt < popup.life;
            });
        }

        function updateGame() {
            const currentTime = Date.now();
            
            if (currentTime - gameState.lastSecondUpdate > 1000) {
                if (gameState.gamePhase === 'preparation') {
                    gameState.preparationTimeLeft -= 1;
                    
                    if (gameState.preparationTimeLeft <= 0) {
                        startBattle();
                    }
                } else if (gameState.gamePhase === 'battle' && !gameState.gameOver) {
                    gameState.battleTimeLeft -= 1;
                    
                    gameState.enemySpawnTimer += 1;
                    if (gameState.enemySpawnTimer >= 2) {
                        spawnEnemyUnit();
                        gameState.enemySpawnTimer = 0;
                    }
                }
                
                gameState.lastSecondUpdate = currentTime;
                updateStats();
            }
            
            if (!gameState.gameOver) {
                updateUnits();
                
                if (gameState.playerHealth <= 0) {
                    gameState.gameOver = true;
                    showGameResult('lose');
                } else if (gameState.gamePhase === 'battle' && gameState.battleTimeLeft <= 0) {
                    gameState.gameOver = true;
                    showGameResult('win');
                }
            }
        }

        function startBattle() {
            gameState.gamePhase = 'battle';
            document.getElementById('preparation-panel').classList.add('hidden');
        }

        function showGameResult(result) {
            const resultDiv = document.getElementById('game-result');
            const title = document.getElementById('result-title');
            const message = document.getElementById('result-message');
            
            if (result === 'win') {
                title.textContent = 'ПОБЕДА!';
                message.textContent = '+1 ключ, +50 золота';
                
                // Сохранение награды
                const progress = JSON.parse(localStorage.getItem('fortressBattleProgress') || '{}');
                progress.keys = (progress.keys || 0) + 1;
                progress.gold = (progress.gold || 0) + 50;
                localStorage.setItem('fortressBattleProgress', JSON.stringify(progress));
            } else {
                title.textContent = 'ПОРАЖЕНИЕ';
                message.textContent = 'Попробуйте еще раз!';
            }
            
            resultDiv.classList.remove('hidden');
        }

        function renderGame() {
            // Очистка canvas
            ctx.fillStyle = '#7cb342';
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            
            // Текстура травы
            ctx.fillStyle = '#689f38';
            for (let i = 0; i < SCREEN_WIDTH; i += 20) {
                for (let j = 0; j < SCREEN_HEIGHT; j += 20) {
                    if ((i + j) % 40 === 0) {
                        ctx.fillRect(i, j, 10, 10);
                    }
                }
            }
            
            // Крепость игрока
            const castleX = SCREEN_WIDTH / 2;
            const castleY = SCREEN_HEIGHT / 2;
            
            ctx.fillStyle = '#6d4c41';
            ctx.beginPath();
            ctx.arc(castleX, castleY, 80, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(castleX - 40, castleY - 60, 80, 40);
            ctx.fillRect(castleX - 60, castleY - 20, 120, 20);
            
            // Полоска здоровья замка
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(castleX - 50, castleY - 80, 100, 10);
            ctx.fillStyle = '#ef5350';
            ctx.fillRect(castleX - 50, castleY - 80, 100 * (gameState.playerHealth / gameState.maxCastleHealth), 10);
            
            // Юниты игрока
            gameState.units.forEach(unit => {
                const character = characters[unit.characterId];
                
                // Юнит
                ctx.fillStyle = '#8d6e63';
                ctx.beginPath();
                ctx.arc(unit.x, unit.y, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Полоска здоровья
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(unit.x - 30, unit.y - 40, 60, 8);
                ctx.fillStyle = '#4caf50';
                ctx.fillRect(unit.x - 30, unit.y - 40, 60 * (unit.health / unit.maxHealth), 8);
                
                // Индикатор состояния
                if (unit.isExecuting) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#4fc3f7';
                    ctx.textAlign = 'center';
                    ctx.fillText('⚡', unit.x, unit.y - 50);
                }
                
                // Выделение выбранного юнита
                if (gameState.selectedUnit === unit) {
                    ctx.strokeStyle = '#4fc3f7';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, 35, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Кнопка программирования
                    ctx.fillStyle = 'rgba(93, 64, 55, 0.9)';
                    ctx.fillRect(unit.x - 40, unit.y - 80, 80, 25);
                    ctx.strokeStyle = '#8d6e63';
                    ctx.strokeRect(unit.x - 40, unit.y - 80, 80, 25);
                    ctx.fillStyle = '#f5e8c8';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Программировать', unit.x, unit.y - 65);
                }
            });
            
            // Вражеские юниты
            gameState.enemyUnits.forEach(unit => {
                ctx.fillStyle = '#5d4037';
                ctx.beginPath();
                ctx.arc(unit.x, unit.y, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ef5350';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ВРАГ', unit.x, unit.y + 5);
                
                // Полоска здоровья
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(unit.x - 30, unit.y - 40, 60, 8);
                ctx.fillStyle = '#4caf50';
                ctx.fillRect(unit.x - 30, unit.y - 40, 60 * (unit.health / unit.maxHealth), 8);
            });
            
            // Всплывающие сообщения об уроне
            const now = Date.now();
            gameState.damagePopups.forEach(popup => {
                const progress = (now - popup.createdAt) / popup.life;
                const y = popup.y - progress * 50;
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = popup.color;
                ctx.textAlign = 'center';
                ctx.fillText(popup.text, popup.x, y);
                ctx.restore();
            });
            
            // Область размещения (в фазе подготовки)
            if (gameState.gamePhase === 'preparation') {
                ctx.strokeStyle = 'rgba(79, 195, 247, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(castleX, castleY, 120, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function handleCanvasClick(x, y) {
            if (gameState.gameOver) return;
            
            // Проверка кнопки программирования
            if (gameState.selectedUnit) {
                const unit = gameState.selectedUnit;
                if (x >= unit.x - 40 && x <= unit.x + 40 && 
                    y >= unit.y - 80 && y <= unit.y - 55) {
                    openProgrammingPanel();
                    return;
                }
            }
            
            if (gameState.selectedCharacter) {
                placeUnit(x, y);
            } else {
                if (!selectUnit(x, y)) {
                    gameState.selectedCharacter = null;
                    gameState.selectedUnit = null;
                }
            }
        }

        // Обработчики событий
        function setupEventListeners() {
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                handleCanvasClick(x, y);
            });

            document.getElementById('start-early-btn').addEventListener('click', startBattle);
            document.getElementById('apply-program-btn').addEventListener('click', applyProgram);
            document.getElementById('apply-all-btn').addEventListener('click', applyProgramToAll);
            document.getElementById('apply-type-btn').addEventListener('click', applyProgramToType);
            document.getElementById('close-programming-btn').addEventListener('click', closeProgrammingPanel);
            document.getElementById('continue-btn').addEventListener('click', () => {
                window.location.href = 'index.html';
            });
        }

        // Игровой цикл
        function gameLoop() {
            updateGame();
            renderGame();
            requestAnimationFrame(gameLoop);
        }

        // Инициализация
        function init() {
            loadProgress();
            createCharacterButtons();
            setupEventListeners();
            updateStats();
            gameState.lastSecondUpdate = Date.now();
            gameLoop();
        }

        // Запуск игры
        init();
    </script>
</body>
</html>
